---
# Source: ogscloud/charts/geoservercloud/charts/rabbitmq/templates/serviceaccount.yaml
apiVersion: v1
kind: ServiceAccount
metadata:
  name: testwithveryveryverylongreleasename-rabbitmq
  namespace: "default"
  labels:
    app.kubernetes.io/name: rabbitmq
    helm.sh/chart: rabbitmq-11.3.0
    app.kubernetes.io/instance: testwithveryveryverylongreleasename
    app.kubernetes.io/managed-by: Helm
automountServiceAccountToken: true
secrets:
  - name: testwithveryveryverylongreleasename-rabbitmq
---
# Source: ogscloud/charts/geoservercloud/templates/serviceaccount.yaml
apiVersion: v1
kind: ServiceAccount
metadata:
  name: testwithveryveryverylongreleasename-geoser
  labels:
    helm.sh/chart: geoservercloud-0.0.49
    deployed_by: helm
    app.kubernetes.io/app_environment: "master"
    app.kubernetes.io/base_environment: "dev"
    app.kubernetes.io/name: geoservercloud
    app.kubernetes.io/instance: testwithveryveryverylongreleasename
    app.kubernetes.io/version: "1.0-RC30"
    app.kubernetes.io/managed-by: Helm
---
# Source: ogscloud/charts/geoservercloud/charts/rabbitmq/templates/config-secret.yaml
apiVersion: v1
kind: Secret
metadata:
  name: testwithveryveryverylongreleasename-rabbitmq-config
  namespace: "default"
  labels:
    app.kubernetes.io/name: rabbitmq
    helm.sh/chart: rabbitmq-11.3.0
    app.kubernetes.io/instance: testwithveryveryverylongreleasename
    app.kubernetes.io/managed-by: Helm
type: Opaque
data:
  rabbitmq.conf: |-
    IyMgVXNlcm5hbWUgYW5kIHBhc3N3b3JkCiMjCmRlZmF1bHRfdXNlciA9IGdlb3NlcnZlcgojIyBDbHVzdGVyaW5nCiMjCmNsdXN0ZXJfZm9ybWF0aW9uLnBlZXJfZGlzY292ZXJ5X2JhY2tlbmQgID0gcmFiYml0X3BlZXJfZGlzY292ZXJ5X2s4cwpjbHVzdGVyX2Zvcm1hdGlvbi5rOHMuaG9zdCA9IGt1YmVybmV0ZXMuZGVmYXVsdApjbHVzdGVyX2Zvcm1hdGlvbi5ub2RlX2NsZWFudXAuaW50ZXJ2YWwgPSAxMApjbHVzdGVyX2Zvcm1hdGlvbi5ub2RlX2NsZWFudXAub25seV9sb2dfd2FybmluZyA9IHRydWUKY2x1c3Rlcl9wYXJ0aXRpb25faGFuZGxpbmcgPSBhdXRvaGVhbAojIHF1ZXVlIG1hc3RlciBsb2NhdG9yCnF1ZXVlX21hc3Rlcl9sb2NhdG9yID0gbWluLW1hc3RlcnMKIyBlbmFibGUgZ3Vlc3QgdXNlcgpsb29wYmFja191c2Vycy5ndWVzdCA9IGZhbHNlCiNkZWZhdWx0X3Zob3N0ID0gZGVmYXVsdC12aG9zdAojZGlza19mcmVlX2xpbWl0LmFic29sdXRlID0gNTBNQg==
---
# Source: ogscloud/charts/geoservercloud/charts/rabbitmq/templates/secrets.yaml
apiVersion: v1
kind: Secret
metadata:
  name: testwithveryveryverylongreleasename-rabbitmq
  namespace: "default"
  labels:
    app.kubernetes.io/name: rabbitmq
    helm.sh/chart: rabbitmq-11.3.0
    app.kubernetes.io/instance: testwithveryveryverylongreleasename
    app.kubernetes.io/managed-by: Helm
type: Opaque
data:
  rabbitmq-password: "blVRU0owYnpiUnNxR1dOMA=="

  rabbitmq-erlang-cookie: "amZDU3c0VnJJN1BFYmJsYjh6U1RSejFBM0luMk5WZEw="
---
# Source: ogscloud/charts/geoservercloud/templates/secrets/secret_postgres.yaml
apiVersion: v1
data:
  DATABASE_NAME: Y29uZmln
  HOST: dGVzdHdpdGh2ZXJ5dmVyeXZlcnlsb25ncmVsZWFzZW5hbWUtcG9zdGdyZXNxbA==
  ROLE: dXNlcm5hbWU=
  PASSWORD: cGFzc3dvcmQ=
  PORT: NTQzMg==


kind: Secret
metadata:
  name: jdbcconfig-testwithveryveryverylongreleasename-geoser
type: Opaque
---
# Source: ogscloud/charts/geoservercloud/templates/config/configmap.yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: testwithveryveryverylongreleasename-geoser-config-configs
  labels:
    helm.sh/chart: geoservercloud-0.0.49
    deployed_by: helm
    app.kubernetes.io/app_environment: "master"
    app.kubernetes.io/base_environment: "dev"
    app.kubernetes.io/name: geoservercloud
    app.kubernetes.io/instance: testwithveryveryverylongreleasename
    app.kubernetes.io/version: "1.0-RC30"
    app.kubernetes.io/managed-by: Helm
    app.kubernetes.io/component: "config"
data:
  config-service.yml: |-
    # Should only be set in application.yml. Setting the value in bootstrap.yml will cause undesirable side effects like registering in eureka with an UNKNOWN status.
    # See https://cloud.spring.io/spring-cloud-netflix/2.0.x/multi/multi__service_discovery_eureka_clients.html#_eureka_s_health_checks
    eureka.client.healthcheck.enabled: false

  gateway-service.yml: |-
    # Defines the root base path at which the gateway exposes all geoserver request paths
    # We're not setting the spring.webflux.base-path because spring-cloud Gateway doesn't
    # work properly with it. See https://github.com/spring-cloud/spring-cloud-gateway/issues/1759
    # For example, if geoserver.base-path=/geoserver-cloud, then geoserver requests will be served
    # under that path prefix (e.g. http://localhost:9090/geoserver-cloud/web, http://localhost:9090/geoserver-cloud/wfs, etc)
    # Examples:
    #geoserver.base-path:
    #geoserver.base-path: /geoserver-cloud
    #geoserver.base-path: /geoserver/cloud
    # Leave it empty for no additional path, setting it to / won't work currently
    #
    # Please note any other prefix than the empty string will require a trailing slash in the root URL
    # for the redirection to the web-ui to work. This is something we need to fix. For example:
    # http://localhost:9090/geoserver-cloud will return 404, but http://localhost:9090/geoserver-cloud/ will work.
    geoserver.base-path: ${geoserver_base_path:}

    # by default, assumes a discovery-client is in use, and perform client-side load balancing on
    # the advertised instances. See the 'static_routes' profile notes for a static config
    targets:
      catalog: lb://catalog-service
      wfs: lb://wfs-service
      wms: lb://wms-service
      wcs: lb://wcs-service
      wps: lb://wps-service
      rest: lb://restconfig-v1
      gwc: lb://gwc-service
      webui: lb://web-ui

    # Configure routes to services. See https://cloud.spring.io/spring-cloud-gateway/single/spring-cloud-gateway.html
    server:
      compression:
        enabled: true

    spring:
      cloud:
        gateway:
          globalcors:
            cors-configurations:
              "[/**]":
                allowedOrigins: "*"
                allowedMethods:
                  - GET
                  - PUT
                  - POST
                  - DELETE
                  - OPTIONS
                  - HEAD
          default-filters:
            - StripBasePath=${geoserver.base-path} #remove the base path on downstream requests
          actuator:
            verbose:
              enabled: true
          routes:
            - id: catalog
              uri: ${targets.catalog}
              predicates:
                - Path=${geoserver.base-path}/api/v1/**
              filters: # Expose the catalog and configuration API only if the dev profile is active
                - RouteProfile=dev,403
            # WFS routes
            - id: wfs # proxies requests to gateway-service:/wfs to wfs-service:/wfs
              uri: ${targets.wfs}
              predicates:
                - Path=${geoserver.base-path}/wfs,${geoserver.base-path}/{workspace}/wfs,${geoserver.base-path}/{workspace}/{layer}/wfs,${geoserver.base-path}/schemas/wfs/**
            # proxy [/{workspace}]/ows?SERVICE=wfs to wfs-service:[/{workspace}]/ows?SERVICE=wfs. Param value is case insensitive, name is not.
            - id: wfs_ows
              uri: ${targets.wfs}
              predicates:
                - Path=${geoserver.base-path}/ows,${geoserver.base-path}/{workspace}/ows,${geoserver.base-path}/{workspace}/{layer}/ows
                - RegExpQuery=(?i:service),(?i:wfs) # match service=wfs case insensitively
            # WMS routes
            - id: wms # proxies requests to gateway-service:/wms to wms-service:/wms
              uri: ${targets.wms}
              predicates:
                - Path=${geoserver.base-path}/wms,${geoserver.base-path}/{workspace}/wms,${geoserver.base-path}/{workspace}/{layer}/wms,${geoserver.base-path}/schemas/wms/**,${geoserver.base-path}/openlayers/**,${geoserver.base-path}/openlayers3/**
            - id: wms_ows # proxy [/{workspace}]/ows?SERVICE=wms to wms-service:[/{workspace}]/ows?SERVICE=wms. Param value is case insensitive, name is not.
              uri: ${targets.wms}
              predicates:
                - Path=${geoserver.base-path}/ows,${geoserver.base-path}/{workspace}/ows,${geoserver.base-path}/{workspace}/{layer}/ows
                - RegExpQuery=(?i:service),(?i:wms) # match service=wms case insensitively
            - id: kml # proxies requests to kml endpoints to the wms service
              uri: ${targets.wms}
              predicates:
                - Path=${geoserver.base-path}/wms/kml,${geoserver.base-path}/{workspace}/wms/kml,${geoserver.base-path}/kml/icon/**
            # WCS routes
            - id: wcs # proxies requests to gateway-service:/wcs to wcs-service:/wcs
              uri: ${targets.wcs}
              predicates:
                - Path=${geoserver.base-path}/wcs,${geoserver.base-path}/{workspace}/wcs,${geoserver.base-path}/{workspace}/{layer}/wcs,${geoserver.base-path}/schemas/wcs/**
            - id: wcs_ows # proxy [/{workspace}]/ows?SERVICE=wcs to wcs-service:[/{workspace}]/ows?SERVICE=wcs. Param value is case insensitive, name is not.
              uri: ${targets.wcs}
              predicates:
                - Path=${geoserver.base-path}/ows,${geoserver.base-path}/{workspace}/ows,${geoserver.base-path}/{workspace}/{layer}/ows
                - RegExpQuery=(?i:service),(?i:wcs) # match service=wcs case insensitively
            # WPS routes
            - id: wps # proxies requests to gateway-service:/wps to wfs-service:/wps
              uri: ${targets.wps}
              predicates:
                - Path=${geoserver.base-path}/wps,${geoserver.base-path}/{segment}/wps,${geoserver.base-path}/schemas/wps/**
            - id: wps_ows # proxy [/{workspace}]/ows?SERVICE=wps to wps-service:[/{workspace}]/ows?SERVICE=wps. Param value is case insensitive, name is not.
              uri: ${targets.wps}
              predicates:
                - Path=${geoserver.base-path}/ows,${geoserver.base-path}/{segment}/ows
                - RegExpQuery=(?i:service),(?i:wps) # match service=wps case insensitively
            # REST configuration routes
            - id: restconfig
              uri: ${targets.rest}
              predicates:
                - Path=${geoserver.base-path}/rest/**
            # GeoWebcache configuration routes
            - id: gwc
              uri: ${targets.gwc}
              predicates:
                - Path=${geoserver.base-path}/gwc/**,${geoserver.base-path}/{workspace}/gwc/**,${geoserver.base-path}/{workspace}/{layer}/gwc/**
            # Web UI configuration routes
            - id: webui
              uri: ${targets.webui}
              predicates:
                - Path=${geoserver.base-path}/**
              #- Path=${geoserver.base-path},${geoserver.base-path}/,${geoserver.base-path}/index.html,${geoserver.base-path}/web,${geoserver.base-path}/web/**,${geoserver.base-path}/j_spring_security_check,${geoserver.base-path}/j_spring_security_logout

    management:
      endpoints:
        enabled-by-default: true
        web.exposure.include: "*"
      endpoint:
        info.enabled: true
        metrics.enabled: true
        shutdown.enabled: true
        health:
          enabled: true
          show-details: always
      metrics:
        binders:
          processor.enabled: true
          uptime.enabled: true
          jvm.enabled: true
        enable.all: true
        enable.jvm: true
        export:
          atlas.enabled: false

    ---
    # this profile is automatically included if any of the embedded
    # config_first or discovery_first profile groups are active
    spring.config.activate.on-profile: discovery_eureka
    # Should only be set in application.yml. Setting the value in bootstrap.yml will cause undesirable side effects like registering in eureka with an UNKNOWN status.
    # See https://cloud.spring.io/spring-cloud-netflix/2.0.x/multi/multi__service_discovery_eureka_clients.html#_eureka_s_health_checks
    eureka.client.healthcheck.enabled: true
    eureka.server.url: http://discovery:8761/eureka
    ---
    spring.config.activate.on-profile: standalone
    # Define static targets using known host names.
    # Host names can be docker-compose assigned service names, or k8s service names as appropriate
    targets:
      catalog: http://catalog:8080
      wfs: http://wfs:8080
      wms: http://wms:8080
      wcs: http://wcs:8080
      wps: http://wps:8080
      rest: http://rest:8080
      gwc: http://gwc:8080
      webui: http://webui:8080
    ---
    spring.config.activate.on-profile: local
    targets:
      catalog: http://localhost:9100
      wfs: http://localhost:9101
      wms: http://localhost:9102
      wcs: http://localhost:9103
      wps: http://localhost:9104
      rest: http://localhost:9105
      webui: http://localhost:9106
      gwc: http://localhost:9107

  geoserver.yml: |-
    # This configuration file is imported by all geoserver-specific services' bootstrap.yml
    # For the sake of clarity, configuration properties relative to the spring-boot application
    # itself is imported from geoserver_spring.yml, and properties specific to geoserver from this file.
    spring.config.import:
     - geoserver_spring.yml
     - jndi.yml

    # The following geoserver, geotools, and geowebcache configuration properties
    # are common to all geoserver microservices, despite some may not apply to a given service,
    # it's easier to have them all here in the default spring profile.
    # Common configuration for all services. Override or add service specific config
    # properties on each <service-name>-service.yml file

    # GeoServer-Cloud common config properties
    geoserver:
      debug:
        # add an X-gs-cloud-service-id:<service-id> response header to each response
        # to track which cluster node replied
        instanceId: false
      metrics:
        enabled: true
        instance-id: ${info.instance-id}
      security:
        enabled: true
        authkey: true
      servlet.filter.session-debug.enabled: false # until the NPE is fixed
      catalog:
        advertised: true
        localWorkspace: true
        isolated: true
        secure: true
        # enable if needed on a backend-specific profile (e.g. jdbcconfig)
        caching.enabled: false
      bus:
        # whether to send distributed events (i.e. acts as master). All instances receive remote events.
        send-events: true
        # whether to send the object (CatalogInfo/config info) as payload with the event. Set to false,
        # not all possible payload types are properly tested, and full object payload is not needed.
        send-object: ${geoserver.backend.data-directory.enabled}
        # whether to send a diff of changes as payload with the event. Set to false, not all possible payload types are properly tested nor needed.
        send-diff: ${geoserver.backend.data-directory.enabled}
      backend:
        # configure catalog backends and decide which backend to use on this service.
        # All backends are disabled, enable the required one on each service. For example, the catalog microservice
        # will enable one backend type, and the front services the catalog-service backend.
        # revisit: Could be split into profiles
        catalog-service:
          enabled: ${backend.catalog:false}
          # Base URI of the catalog service. If not set, will be automatically determined using the discovery service, looking for "catalog-service"
          # This allows to explicitly set a fixed location for the catalog service.
          # uri: http://catalog:8080
          cache-directory: ${java.io.tmpdir}/cngs/catalog-client/resource_store
          fallback-resource-directory: ${java.io.tmpdir}/cngs/catalog-client/fallback_resource_store
        data-directory:
          enabled: ${backend.data-directory:false}
          location: ${GEOSERVER_DATA_DIR:/opt/app/data_directory}
          # use optimized parallel datadirectory loader. Defaults to true
          parallel-loader: true
        jdbcconfig:
          enabled: ${backend.jdbcconfig:false}
          initdb: true
          web.enabled: true
          cache-directory: ${jdbcconfig.cachedir:${java.io.tmpdir}/cngs/jdbcconfig/cache}
          datasource:
            url: "${jdbcconfig.url:jdbc:postgresql://${jdbcconfig.host:database}:${jdbcconfig.port:5432}/${jdbcconfig.database:geoserver_config}?currentSchema=${jdbcconfig.schema:public}}"
            username: ${jdbcconfig.username:geoserver}
            password: ${jdbcconfig.password:geo5erver}
            driverClassname: ${jdbcconfig.driverClassname:org.postgresql.Driver}
            # optional:
            minimumIdle: ${jdbcconfig.minConnections:0}
            maximumPoolSize: ${jdbcconfig.maxConnections:8}
            connectionTimeout: ${jdbcconfig.connectionTimeout:250}
            idleTimeout: ${jdbcconfig.idleTimeout:10000}
      styling:
        css.enabled: true
        mapbox.enabled: true
      wms:
        reflector.enabled: true
        kml.enabled: true
        output-formats:
          vector-tiles:
            mapbox.enabled: true
            geojson.enabled: true
            topojson.enabled: true

    # GeoTools HTTP Client proxy configuration, allows configuring cascaded WMS/WMTS/WFS stores
    # that need to go through an HTTP proxy without affecting all the http clients at the JVM level
    # These are default settings. The enabled property can be set to false to disable the custom
    # HTTPClientFactory altogether.
    # The following OS environment variables can be set for easier configuration:
    # HTTP(S)_PROXYHOST, HTTP(S)_PROXYPORT, HTTP(S)_PROXYUSER, HTTP(S)_PROXYPASSWORD, HTTP(S)_NONPROXYHOSTS
    geotools:
      httpclient:
        proxy:
          enabled: true
          http:
            host: ${http.proxyHost:}
            port: ${http.proxyPort:}
            user: ${http.proxyUser:}
            password: ${http.proxyPassword:}
            nonProxyHosts: ${http.nonProxyHosts:localhost.*}
            # comma separated list of Java regular expressions, e.g.: nonProxyHosts: localhost, example.*
          https:
            host: ${https.proxyHost:${geotools.httpclient.proxy.http.host}}
            port: ${https.proxyPort:${geotools.httpclient.proxy.http.port}}
            user: ${https.proxyUser:${geotools.httpclient.proxy.http.user}}
            password: ${https.proxyPassword:${geotools.httpclient.proxy.http.password}}
            nonProxyHosts: ${https.nonProxyHosts:${geotools.httpclient.proxy.http.nonProxyHosts}}

    # GeoWebCache-specific configuration properties, apply to services that run some GWC
    # internal components. For example, all of gwc-service, wms-service, and web-ui, will
    # need to access GeoWebCache's blob stores, and tile-layer configuration resources.
    # wms-service and web-ui won't event load components related to GWC REST/Web APIs, web UI,
    # and others. Unlike web-ui, wms-service will load the internal components needed for
    # on-demand tile seeding in order to serve WMC-C tiled requests if gwc.wms-integration=true,
    # so that gwc/wms-c integration workds independently of gwc-service.
    gwc:
      enabled: true
      cache-directory: ${GEOWEBCACHE_CACHE_DIR:${geoserver.backend.data-directory.location}/gwc}
      rest-config: true
      web-ui: true
      wms-integration: true
      services:
        wmts: true
        tms: true
        wms: true
        kml: true
        gmaps: true
        mgmaps: true
      blobstores:
        azure: true
        s3: true

    ###################################################
    #### GeoServer configuration backend profiles: ####
    ---
    spring.config.activate.on-profile: datadir
    backend.jdbcconfig: false
    backend.catalog: false
    backend.data-directory: true

    ---
    spring.config.activate.on-profile: jdbcconfig
    backend.jdbcconfig: true
    backend.catalog: false
    backend.data-directory: false

    geoserver:
      catalog:
        # not sure why isolated workspaces don't work with jdbcconfig as backend
        isolated: false
        # enable caching if using the jdbcconfig as backend, reduces the number of db roundtrips considerably
        caching.enabled: true

    ---
    spring.config.activate.on-profile: catalog
    backend.catalog: true
    backend.jdbcconfig: false
    backend.data-directory: false
    geoserver:
      catalog:
        # enable caching if using the catalog-client as backend
        caching.enabled: true

    #############################################
    #### per microservice-specific profiles: ####
    ---
    spring.config.activate.on-profile: wfs_service
    ---
    spring.config.activate.on-profile: wms_service
    ---
    spring.config.activate.on-profile: wcs_service
    ---
    spring.config.activate.on-profile: wps_service
    ---
    spring.config.activate.on-profile: restconfig_service
    ---
    spring.config.activate.on-profile: gwc_service
    ---
    spring.config.activate.on-profile: webui_service
    geoserver:
      backend.catalog-service.enabled: ${backend.catalog:true}
      web-ui:
        file-browser.hide-file-system: ${webui.hide-filesystem:false}
        # These are all default values, here just for reference. You can omit them and add only the ones to disable or further configure
        security.enabled: true
        wfs.enabled: ${webui.wfs.enabled:true}
        wms.enabled: ${webui.wms.enabled:true}
        wcs.enabled: ${webui.wcs.enabled:true}
        wps.enabled: false # not working yet
        gwc:
          enabled: ${gwc.enabled:false}
          capabilities:
            tms: ${gwc.services.tms:false}
            wmts: ${gwc.services.wmts:false}
            wmsc: ${gwc.services.wms:false}
        extensions:
          importer.enabled: ${webui.importer.enabled:false}
          geostyler.enabled: ${webui.geostyler.enabled:true}
        demos:
          enabled: ${webui.demos.enabled:true}
          wps-request-builder: true
          wcs-request-builder: true
          demo-requests: true
          srs-list: true
          reprojection-console: true
          layer-preview-page:
            enabled: ${webui.preview.enabled:true}
            common-formats:
              open-layers: true
              gml: true
              kml: true
        tools:
          enabled: ${webui.tools.enabled:true}
          resource-browser: true
          catalog-bulk-load: true
    ---
    spring.config.activate.on-profile: catalog_service
    geoserver:
      security.enabled: false
      # Disable advertised catalog, it checks the org.geoserver.ows.Dispatcher.REQUEST to check if an OWS is in progress,
      # which can never be the case, and causes a java.lang.NoClassDefFoundError on org.springframework.web.servlet.mvc.AbstractController
      catalog:
        advertised: false
        # Disable catalog decorators, this service exposes a "raw catalog" backend
        localWorkspace: false
        secure: false
        isolated: false
        # enable caching while using the jdbcconfig backend, we've disabled its own internal caching due to concurrency related bugs
        caching.enabled: ${geoserver.backend.jdbcconfig.enabled}
      catalog-service:
        io-threads:
          # Number of back-end threads to hit the actual catalog with. Defaults 4 * number of cores if unset.
          # If using jdbcconfig, let io-threads be about half the size of geoserver.backend.jdbcconfig.datasource.maximumPoolSize,
          # it has the tendency to use more than one jdbc connection for some requests.
          max-size: ${catalog.io.threads:8}
          # maximum number of queued requests per worker thread before rejecting new requests
          max-queued: ${catalog.io.maxQueued:10000}
      # receive events but don't publish, it's the front catalogs that publish events to better track where the changes come from
      bus.send-events: false
      # decide which catalog backend to use on this service, defaults to jdbcconfig
      backend.jdbcconfig.enabled: ${backend.jdbcconfig:true}
    ---
    # local profile, used for development only. Other settings like config and eureka urls in gs_cloud_bootstrap_profiles.yml
    spring.config.activate.on-profile: local
    geoserver.backend.jdbcconfig.datasource.url: jdbc:postgresql://localhost:54321/geoserver_config?currentSchema=public


  geoserver_spring.yml: |-
    # Spring Boot application-specific config properties to be shared by all
    # GeoServer microservices. Imported from geoserver.yml, in order to separate
    # application from geoserver configuration.
    server:
      tomcat:
        # Maximum number of connections that the server accepts and processes at any given time.
        # Once the limit has been reached, the operating system may still accept connections based on the "acceptCount" property.
        max-connections: ${tomcat.max.connections:8192}
        # Maximum queue length for incoming connection requests when all possible request processing threads are in use.
        accept-count: ${tomcat.accept.count:100}
        accesslog.enabled: ${tomcat.accesslog.enabled:false}
        mbeanregistry.enabled: ${tomcat.mbeanregistry.enabled:false}
        threads:
          # Minimum amount of worker threads.
          min-spare: ${tomcat.threads.min.spare:10}
          # Maximum amount of worker threads.
          max: ${tomcat.threads.max:200}

    spring:
      rabbitmq:
        host: ${rabbitmq.host:rabbitmq}
        port: ${rabbitmq.port:5672}
        username: ${rabbitmq.user:guest}
        password: ${rabbitmq.password:guest}
        virtual-host: ${rabbitmq.vhost:}
      cloud:
        bus:
          enabled: true
          id: ${info.instance-id} # use the same instance id for eureka (see service's' bootstrap.yml) and cloud-bus' rabbitmq instance id
          trace.enabled: false #switch on tracing of acks (default off).
        stream:
          bindings:
            springCloudBusOutput:
              destination: gscatalog
            springCloudBusInput:
              destination: gscatalog
      jackson:
        default-property-inclusion: non-empty
        serialization.indent-output: false #set to true if doing manual testing and want formatted output

    reactive.feign.cloud.enabled: true
    reactive.feign.hystrix.enabled: false

    management:
      endpoints:
        enabled-by-default: true
        web.exposure.include: "*"
      endpoint:
        info.enabled: true
        metrics.enabled: true
        shutdown.enabled: true
        health:
          enabled: true
          probes.enabled: true
          show-details: always
      metrics:
        binders:
          processor.enabled: true
          uptime.enabled: true
          jvm.enabled: true
        enable.all: true
        enable.jvm: true
        export:
          atlas.enabled: false

    logging:
      level:
        root: warn
        org.springframework: warn
        org.springframework.cloud.bus: info
        org.springframework.retry: info
        org.springframework.jdbc.support: info
        com.zaxxer.hikari.pool: OFF
        # reactivefeign:
        reactivefeign.client.log: info
        #    com.netflix.eureka.registry.AbstractInstanceRegistry: error # log flooding with "WARN No remote registry available for the remote region us-east-1"
        #    com.netflix.discovery.shared.resolver.aws.ConfigClusterResolver: error # log flooding with "WARN No remote registry available for the remote region us-east-1"
        # geoserver roots
        org.geotools.autoconfigure: info
        oshi.hardware.platform.linux: error
        oshi.software.os: error
        org.geoserver: warn
        org.geoserver.catalog.datadir: info
        org.geoserver.catalog.plugin: info
        org.geoserver.jackson: info
        org.geotools.jackson: info
        org.geoserver.platform: error
        org.geoserver.platform.resource.MemoryLockProvider: info
        org.geoserver.platform.resource.NioFileLockProvider: info
        org.geoserver.platform.resource.FileLockProvider: info
        org.geoserver.jdbcconfig: info
        org.geoserver.security: info
        org.geoserver.cloud.security: info
        # gs-cloud roots
        org.geoserver.cloud: info
        org.geoserver.cloud.autoconfigure: info
        org.geoserver.cloud.config.factory: info
        # bus debugging
        org.geoserver.cloud.bus: info
        org.geoserver.cloud.event: info
        org.springframework.cloud.bus.BusAutoConfiguration: info
        org.springframework.cloud.bus.DefaultBusPathMatcher: info

    ---
    # this profile is automatically included if any of the embedded
    # config_first or discovery_first profile groups are active
    spring.config.activate.on-profile: discovery_eureka
    # Should only be set in application.yml (i.e. not in bootstrap.yml).
    # Setting the value in bootstrap.yml will cause undesirable side effects like registering in eureka with an UNKNOWN status.
    # See https://cloud.spring.io/spring-cloud-netflix/2.0.x/multi/multi__service_discovery_eureka_clients.html#_eureka_s_health_checks
    eureka.client.healthcheck.enabled: true
    eureka.server.url: http://discovery:8761/eureka

    ---
    spring.config.activate.on-profile: debug
    logging:
      level:
        root: info
        org.springframework: info
        # geoserver roots
        org.geoserver: info
        org.geoserver.catalog: debug
        org.geoserver.catalog.datadir: debug
        org.geoserver.catalog.plugin: debug
        org.geoserver.wms: info
        org.geoserver.wfs: info
        org.geoserver.jackson: debug
        org.geotools.jackson: debug
        org.geoserver.platform: error
        org.geoserver.platform.resource.MemoryLockProvider: info
        org.geoserver.platform.resource.NioFileLockProvider: debug
        org.geoserver.platform.resource.FileLockProvider: debug
        org.geoserver.jdbcconfig: info
        org.geoserver.security: debug
        org.geoserver.cloud.security: debug
        # gs-cloud roots
        org.geoserver.cloud: debug
        org.geoserver.cloud.config: debug
        org.geoserver.cloud.autoconfigure: trace
        org.geoserver.cloud.config.factory: trace
        org.geoserver.cloud.gwc: debug
        # bus debugging
        org.geoserver.cloud.bus: trace
        org.geoserver.cloud.event: debug
        org.springframework.cloud.bus: debug
        org.springframework.cloud.bus.BusAutoConfiguration: info
        org.springframework.cloud.bus.DefaultBusPathMatcher: info
        # reactivefeign:
        reactivefeign.client.log: info

  jndi.yml: |-
    # This file is imported from geoserver.yml and allows to configure multiple JNDI Datasources
    # using standard spring-boot externalized configuration, without having to tweak
    # application container specific fongiuration files (i.e. tomcat, jetty, etc. xml config files)
    #
    # Each JNDI datasource configuration properties is named after the jndi.datasources property,
    # has the following attribtues:
    #
    # * enabled: Whether the datasource shall be configured. Defaults to true.
    # * wait-for-it: Whether to wait for the datasource to be ready (connection succeed) at startup
    # * wait-timeout: Timeout in seconds to wait for the datasource to be ready. Defaults to 60
    # * url: JDBC connection url. Required.
    # * username: Database username to connect as
    # * password: Database user password
    # * driver-class-name: JDBC driver class name. Optional, should be inferred from the URL
    # * maximum-pool-size: Maximum number of connections in the pool. Defaults to 10.
    # * minimum-idle: Minimum number of connections kept alive in the pool. Defaults to 2.
    # * connection-timeout: Connection timeout in milliseconds. Defaults to 250, which is also the minimum allowed value
    # * idle-timeout: Maximum time in milliseconds to keep a connection alive while idle. Defaults to 60000.
    #
    # The data source names will be bound as java:comp/env/jdbc/<name> (e.g. java:comp/env/jdbc/ds1 for
    # a datasource called jndi.datasources.ds1):
    #
    jndi:
      datasources:
        postgis:
          enabled: false
          wait-for-it: true
          wait-timeout: 10
          url: jdbc:postgresql://postgis:5432/postgis
          username: postgis
          password: postgis
          maximum-pool-size: 10
          minimum-idle: 2
          connection-timeout: 250
          idle-timeout: 60000
---
# Source: ogscloud/charts/geoservercloud/charts/rabbitmq/templates/role.yaml
kind: Role
apiVersion: rbac.authorization.k8s.io/v1
metadata:
  name: testwithveryveryverylongreleasename-rabbitmq-endpoint-reader
  namespace: "default"
  labels:
    app.kubernetes.io/name: rabbitmq
    helm.sh/chart: rabbitmq-11.3.0
    app.kubernetes.io/instance: testwithveryveryverylongreleasename
    app.kubernetes.io/managed-by: Helm
rules:
  - apiGroups: [""]
    resources: ["endpoints"]
    verbs: ["get"]
  - apiGroups: [""]
    resources: ["events"]
    verbs: ["create"]
---
# Source: ogscloud/charts/geoservercloud/charts/rabbitmq/templates/rolebinding.yaml
kind: RoleBinding
apiVersion: rbac.authorization.k8s.io/v1
metadata:
  name: testwithveryveryverylongreleasename-rabbitmq-endpoint-reader
  namespace: "default"
  labels:
    app.kubernetes.io/name: rabbitmq
    helm.sh/chart: rabbitmq-11.3.0
    app.kubernetes.io/instance: testwithveryveryverylongreleasename
    app.kubernetes.io/managed-by: Helm
subjects:
  - kind: ServiceAccount
    name: testwithveryveryverylongreleasename-rabbitmq
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: Role
  name: testwithveryveryverylongreleasename-rabbitmq-endpoint-reader
---
# Source: ogscloud/charts/geoservercloud/charts/rabbitmq/templates/svc-headless.yaml
apiVersion: v1
kind: Service
metadata:
  name: testwithveryveryverylongreleasename-rabbitmq-headless
  namespace: "default"
  labels:
    app.kubernetes.io/name: rabbitmq
    helm.sh/chart: rabbitmq-11.3.0
    app.kubernetes.io/instance: testwithveryveryverylongreleasename
    app.kubernetes.io/managed-by: Helm
spec:
  clusterIP: None
  ports:
    - name: epmd
      port: 4369
      targetPort: epmd
    - name: amqp
      port: 5672
      targetPort: amqp
    - name: dist
      port: 25672
      targetPort: dist
    - name: http-stats
      port: 15672
      targetPort: stats
  selector:
    app.kubernetes.io/name: rabbitmq
    app.kubernetes.io/instance: testwithveryveryverylongreleasename
  publishNotReadyAddresses: true
---
# Source: ogscloud/charts/geoservercloud/charts/rabbitmq/templates/svc.yaml
apiVersion: v1
kind: Service
metadata:
  name: testwithveryveryverylongreleasename-rabbitmq
  namespace: "default"
  labels:
    app.kubernetes.io/name: rabbitmq
    helm.sh/chart: rabbitmq-11.3.0
    app.kubernetes.io/instance: testwithveryveryverylongreleasename
    app.kubernetes.io/managed-by: Helm
spec:
  type: ClusterIP
  sessionAffinity: None
  ports:
    - name: amqp
      port: 5672
      targetPort: amqp
      nodePort: null
    - name: epmd
      port: 4369
      targetPort: epmd
      nodePort: null
    - name: dist
      port: 25672
      targetPort: dist
      nodePort: null
    - name: http-stats
      port: 15672
      targetPort: stats
      nodePort: null
  selector:
    app.kubernetes.io/name: rabbitmq
    app.kubernetes.io/instance: testwithveryveryverylongreleasename
---
# Source: ogscloud/charts/geoservercloud/templates/gateway/service.yaml
apiVersion: v1
kind: Service
metadata:
  name: testwithveryveryverylongreleasename-geoser-gateway
  labels:
    helm.sh/chart: geoservercloud-0.0.49
    deployed_by: helm
    app.kubernetes.io/app_environment: "master"
    app.kubernetes.io/base_environment: "dev"
    app.kubernetes.io/name: geoservercloud
    app.kubernetes.io/instance: testwithveryveryverylongreleasename
    app.kubernetes.io/version: "1.0-RC30"
    app.kubernetes.io/managed-by: Helm
    app.kubernetes.io/component: gateway
  annotations:
    test: gateway
spec:
  type: ClusterIP
  ports:
    - port: 8080
      targetPort: http
      protocol: TCP
      name: http
  selector:
    app.kubernetes.io/name: geoservercloud
    app.kubernetes.io/instance: testwithveryveryverylongreleasename
    app.kubernetes.io/component: gateway
---
# Source: ogscloud/charts/geoservercloud/templates/generic/service_and_deployment.yaml
# service gwc
apiVersion: v1
kind: Service
metadata:
  name: testwithveryveryverylongreleasename-geoser-gwc
  labels:
    helm.sh/chart: geoservercloud-0.0.49
    deployed_by: helm
    app.kubernetes.io/app_environment: "master"
    app.kubernetes.io/base_environment: "dev"
    app.kubernetes.io/name: geoservercloud
    app.kubernetes.io/instance: testwithveryveryverylongreleasename
    app.kubernetes.io/version: "1.0-RC30"
    app.kubernetes.io/managed-by: Helm
    app.kubernetes.io/component: gwc
spec:
  type: ClusterIP
  ports:
    - port: 8080
      targetPort: http
      protocol: TCP
      name: http
  selector:

    app.kubernetes.io/name: geoservercloud
    app.kubernetes.io/instance: testwithveryveryverylongreleasename
    app.kubernetes.io/component: gwc
---
# Source: ogscloud/charts/geoservercloud/templates/generic/service_and_deployment.yaml
# service rest
apiVersion: v1
kind: Service
metadata:
  name: testwithveryveryverylongreleasename-geoser-rest
  labels:
    helm.sh/chart: geoservercloud-0.0.49
    deployed_by: helm
    app.kubernetes.io/app_environment: "master"
    app.kubernetes.io/base_environment: "dev"
    app.kubernetes.io/name: geoservercloud
    app.kubernetes.io/instance: testwithveryveryverylongreleasename
    app.kubernetes.io/version: "1.0-RC30"
    app.kubernetes.io/managed-by: Helm
    app.kubernetes.io/component: rest
spec:
  type: ClusterIP
  ports:
    - port: 8080
      targetPort: http
      protocol: TCP
      name: http
  selector:

    app.kubernetes.io/name: geoservercloud
    app.kubernetes.io/instance: testwithveryveryverylongreleasename
    app.kubernetes.io/component: rest
---
# Source: ogscloud/charts/geoservercloud/templates/generic/service_and_deployment.yaml
# service wcs
apiVersion: v1
kind: Service
metadata:
  name: testwithveryveryverylongreleasename-geoser-wcs
  labels:
    helm.sh/chart: geoservercloud-0.0.49
    deployed_by: helm
    app.kubernetes.io/app_environment: "master"
    app.kubernetes.io/base_environment: "dev"
    app.kubernetes.io/name: geoservercloud
    app.kubernetes.io/instance: testwithveryveryverylongreleasename
    app.kubernetes.io/version: "1.0-RC30"
    app.kubernetes.io/managed-by: Helm
    app.kubernetes.io/component: wcs
spec:
  type: ClusterIP
  ports:
    - port: 8080
      targetPort: http
      protocol: TCP
      name: http
  selector:

    app.kubernetes.io/name: geoservercloud
    app.kubernetes.io/instance: testwithveryveryverylongreleasename
    app.kubernetes.io/component: wcs
---
# Source: ogscloud/charts/geoservercloud/templates/generic/service_and_deployment.yaml
# service webui
apiVersion: v1
kind: Service
metadata:
  name: testwithveryveryverylongreleasename-geoser-webui
  labels:
    helm.sh/chart: geoservercloud-0.0.49
    deployed_by: helm
    app.kubernetes.io/app_environment: "master"
    app.kubernetes.io/base_environment: "dev"
    app.kubernetes.io/name: geoservercloud
    app.kubernetes.io/instance: testwithveryveryverylongreleasename
    app.kubernetes.io/version: "1.0-RC30"
    app.kubernetes.io/managed-by: Helm
    app.kubernetes.io/component: webui
  annotations:
    foo: bar
spec:
  type: ClusterIP
  ports:
    - port: 8080
      targetPort: http
      protocol: TCP
      name: http
  selector:

    app.kubernetes.io/name: geoservercloud
    app.kubernetes.io/instance: testwithveryveryverylongreleasename
    app.kubernetes.io/component: webui
---
# Source: ogscloud/charts/geoservercloud/templates/generic/service_and_deployment.yaml
# service wfs
apiVersion: v1
kind: Service
metadata:
  name: testwithveryveryverylongreleasename-geoser-wfs
  labels:
    helm.sh/chart: geoservercloud-0.0.49
    deployed_by: helm
    app.kubernetes.io/app_environment: "master"
    app.kubernetes.io/base_environment: "dev"
    app.kubernetes.io/name: geoservercloud
    app.kubernetes.io/instance: testwithveryveryverylongreleasename
    app.kubernetes.io/version: "1.0-RC30"
    app.kubernetes.io/managed-by: Helm
    app.kubernetes.io/component: wfs
spec:
  type: ClusterIP
  ports:
    - port: 8080
      targetPort: http
      protocol: TCP
      name: http
  selector:

    app.kubernetes.io/name: geoservercloud
    app.kubernetes.io/instance: testwithveryveryverylongreleasename
    app.kubernetes.io/component: wfs
---
# Source: ogscloud/charts/geoservercloud/templates/generic/service_and_deployment.yaml
# service wms
apiVersion: v1
kind: Service
metadata:
  name: testwithveryveryverylongreleasename-geoser-wms
  labels:
    helm.sh/chart: geoservercloud-0.0.49
    deployed_by: helm
    app.kubernetes.io/app_environment: "master"
    app.kubernetes.io/base_environment: "dev"
    app.kubernetes.io/name: geoservercloud
    app.kubernetes.io/instance: testwithveryveryverylongreleasename
    app.kubernetes.io/version: "1.0-RC30"
    app.kubernetes.io/managed-by: Helm
    app.kubernetes.io/component: wms
spec:
  type: ClusterIP
  ports:
    - port: 8080
      targetPort: http
      protocol: TCP
      name: http
  selector:

    app.kubernetes.io/name: geoservercloud
    app.kubernetes.io/instance: testwithveryveryverylongreleasename
    app.kubernetes.io/component: wms
---
# Source: ogscloud/charts/geoservercloud/templates/gateway/deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: testwithveryveryverylongreleasename-geoser-gateway
  labels:
    helm.sh/chart: geoservercloud-0.0.49
    deployed_by: helm
    app.kubernetes.io/app_environment: "master"
    app.kubernetes.io/base_environment: "dev"
    app.kubernetes.io/name: geoservercloud
    app.kubernetes.io/instance: testwithveryveryverylongreleasename
    app.kubernetes.io/version: "1.0-RC30"
    app.kubernetes.io/managed-by: Helm
    app.kubernetes.io/component: gateway
  annotations:
    test: gateway
spec:
  revisionHistoryLimit: 3
  replicas: 1
  selector:
    matchLabels:
      app.kubernetes.io/name: geoservercloud
      app.kubernetes.io/instance: testwithveryveryverylongreleasename
      app.kubernetes.io/component: gateway
  template:
    metadata:
      annotations:
        checksum/config: 090322f8c3cc601feeb74b7c2282e07fedc136db6688b8c52011fcba26e8e7f7
        specificValues/sha256: e8bd46520d20c5e2dfdb553d200fdd7607a59c6110a8581d5948360a7a12993e
        globalValues/sha256: 130a2567c866307fcd6950b0976112984d2fac6b38c6e55b0a07b3ae8a866247
      labels:
        app.kubernetes.io/name: geoservercloud
        app.kubernetes.io/instance: testwithveryveryverylongreleasename
        app.kubernetes.io/component: gateway
    spec:
      volumes:
        # we define an emptyDir that can be used by optional initContainers if needed
        - name: localshare
          emptyDir: {}
        - name: configs
          configMap:
            name: testwithveryveryverylongreleasename-geoser-config-configs
      initContainers:
        - command:
          - /bin/bash
          - -c
          - touch /mnt/localshare/test.txt;
          image: busybox
          name: extract-config
          volumeMounts:
          - mountPath: /mnt/localshare/
            name: localshare
      serviceAccountName: testwithveryveryverylongreleasename-geoser
      securityContext:
        runAsUser: 630
      containers:
        - name: geoservercloud-gateway
          securityContext:
            {}
          image: "sanitize.me/geoservercloud/geoserver-cloud-gateway:1.0-RC30"
          imagePullPolicy: IfNotPresent
          env:
            - name: TARGETS_WMS
              value: http://testwithveryveryverylongreleasename-geoser-wms:8080
            - name: TARGETS_WFS
              value: http://testwithveryveryverylongreleasename-geoser-wfs:8080
            - name: TARGETS_WCS
              value: http://testwithveryveryverylongreleasename-geoser-wcs:8080
            - name: TARGETS_GWC
              value: http://testwithveryveryverylongreleasename-geoser-gwc:8080
            - name: TARGETS_REST
              value: http://testwithveryveryverylongreleasename-geoser-rest:8080
            - name: TARGETS_WEBUI
              value: http://testwithveryveryverylongreleasename-geoser-webui:8080
            - name: SPRING_PROFILES_ACTIVE
              value: "standalone,jdbcconfig"


            - name: GEOSERVER_BASE_PATH
              value:  /geoserver-cloud
            - name: GEOSERVER_DEBUG_INSTANCEID
              value: "true"
            - name: BACKEND_CATALOG
              value: "false"
            - name: BACKEND_DATA_DIRECTORY
              value: "false"
            - name: BACKEND_JDBCCONFIG
              value: "true"
            - name: JAVA_OPTS
              value: "-DALLOW_ENV_PARAMETRIZATION=true "
            - name: TOMCAT_ACCESSLOG_ENABLED
              value: "true"
            - name: TOMCAT_MBEANREGISTRY_ENABLED
              value: "true"
            - name: TOMCAT_THREADS_MIN_SPARE
              value: "5"
            - name: RABBITMQ_PASSWORD
              valueFrom:
                secretKeyRef:
                  name: testwithveryveryverylongreleasename-rabbitmq
                  key: rabbitmq-password
            - name: RABBITMQ_HOST
              value: testwithveryveryverylongreleasename-rabbitmq
            - name: RABBITMQ_PORT
              value: "5672"
            - name: RABBITMQ_USER
              value: geoserver
            - name: GWC_ENABLED
              value: "true"

          volumeMounts:
            - name: configs
              mountPath: /etc/gscloud
            - name: localshare
              mountPath: /mnt/localshare

          ports:
            - name: http
              containerPort: 8080
              protocol: TCP
            - name: health
              containerPort: 8081
              protocol: TCP
          startupProbe:
            httpGet:
              path: /actuator/health
              port: health
            failureThreshold: 30
            periodSeconds: 10
          livenessProbe:
            httpGet:
              path: /actuator/health
              port: health
            periodSeconds: 10
            failureThreshold: 10
            initialDelaySeconds: 30
          readinessProbe:
            httpGet:
              path: /actuator/health
              port: health
            periodSeconds: 5

          resources:
            limits:
              cpu: 2
              memory: 512Mi
            requests:
              cpu: 0.1
              memory: 128Mi
---
# Source: ogscloud/charts/geoservercloud/templates/generic/service_and_deployment.yaml
# deployment gwc
apiVersion: apps/v1
kind: Deployment
metadata:
  name: testwithveryveryverylongreleasename-geoser-gwc
  labels:
    helm.sh/chart: geoservercloud-0.0.49
    deployed_by: helm
    app.kubernetes.io/app_environment: "master"
    app.kubernetes.io/base_environment: "dev"
    app.kubernetes.io/name: geoservercloud
    app.kubernetes.io/instance: testwithveryveryverylongreleasename
    app.kubernetes.io/version: "1.0-RC30"
    app.kubernetes.io/managed-by: Helm
    app.kubernetes.io/component: gwc
spec:
  revisionHistoryLimit: 3
  replicas: 1
  selector:
    matchLabels:

      app.kubernetes.io/name: geoservercloud
      app.kubernetes.io/instance: testwithveryveryverylongreleasename
      app.kubernetes.io/component: gwc
  template:
    metadata:
      annotations:
        checksum/config: 090322f8c3cc601feeb74b7c2282e07fedc136db6688b8c52011fcba26e8e7f7
        specificValues/sha256: 6ab46366e29d7b8f1dd74a8b0217ed0093bf9137661231ac4a17b050a3356424
        globalValues/sha256: 130a2567c866307fcd6950b0976112984d2fac6b38c6e55b0a07b3ae8a866247
      labels:

        app.kubernetes.io/name: geoservercloud
        app.kubernetes.io/instance: testwithveryveryverylongreleasename
        app.kubernetes.io/component: gwc
    spec:
      volumes:
        # we define an emptyDir that can be used by optional initContainers if needed
        - name: localshare
          emptyDir: {}
        - name: configs
          configMap:
            name: testwithveryveryverylongreleasename-geoser-config-configs
        - name: nfs-pv-storage-rasters
          persistentVolumeClaim:
           claimName: nfs-rasters-pv-claim

      serviceAccountName: testwithveryveryverylongreleasename-geoser
      securityContext:
        runAsUser: 630
      initContainers:
        - command:
          - /bin/bash
          - -c
          - touch /mnt/localshare/test.txt;
          image: busybox
          name: extract-config
          volumeMounts:
          - mountPath: /mnt/localshare/
            name: localshare
      containers:
        - name: gwc
          securityContext:
            {}
          image: "sanitize.me/geoservercloud/geoserver-cloud-gwc:1.0-RC30"
          imagePullPolicy: IfNotPresent
          env:
            - name: SPRING_PROFILES_ACTIVE
              value: "standalone,jdbcconfig"


            - name: GEOSERVER_BASE_PATH
              value:  /geoserver-cloud
            - name: GEOSERVER_DEBUG_INSTANCEID
              value: "true"
            - name: BACKEND_CATALOG
              value: "false"
            - name: BACKEND_DATA_DIRECTORY
              value: "false"
            - name: BACKEND_JDBCCONFIG
              value: "true"
            - name: JAVA_OPTS
              value: "-DALLOW_ENV_PARAMETRIZATION=true "
            - name: TOMCAT_ACCESSLOG_ENABLED
              value: "true"
            - name: TOMCAT_MBEANREGISTRY_ENABLED
              value: "true"
            - name: TOMCAT_THREADS_MIN_SPARE
              value: "5"
            - name: RABBITMQ_PASSWORD
              valueFrom:
                secretKeyRef:
                  name: testwithveryveryverylongreleasename-rabbitmq
                  key: rabbitmq-password
            - name: RABBITMQ_HOST
              value: testwithveryveryverylongreleasename-rabbitmq
            - name: RABBITMQ_PORT
              value: "5672"
            - name: RABBITMQ_USER
              value: geoserver
            - name: GWC_ENABLED
              value: "true"
          ports:
            - name: http
              containerPort: 8080
              protocol: TCP
            - name: health
              containerPort: 8081
              protocol: TCP
          volumeMounts:
            - name: localshare
              mountPath: /mnt/localshare
            - name: configs
              mountPath: /etc/gscloud
            - mountPath: "/var/geoserver/nfsrasters"
              name: nfs-pv-storage-rasters
          startupProbe:
            httpGet:
              path: /actuator/health/liveness
              port: health
            failureThreshold: 30
            periodSeconds: 10
          livenessProbe:
            httpGet:
              path: /actuator/health/liveness
              port: health
            periodSeconds: 10
            failureThreshold: 10
            initialDelaySeconds: 30
          readinessProbe:
            httpGet:
              path: /actuator/health/readiness
              port: health
            periodSeconds: 5

          resources:
            limits:
              cpu: 4
              memory: 4Gi
            requests:
              cpu: 0.1
              memory: 512Mi
---
# Source: ogscloud/charts/geoservercloud/templates/generic/service_and_deployment.yaml
# deployment rest
apiVersion: apps/v1
kind: Deployment
metadata:
  name: testwithveryveryverylongreleasename-geoser-rest
  labels:
    helm.sh/chart: geoservercloud-0.0.49
    deployed_by: helm
    app.kubernetes.io/app_environment: "master"
    app.kubernetes.io/base_environment: "dev"
    app.kubernetes.io/name: geoservercloud
    app.kubernetes.io/instance: testwithveryveryverylongreleasename
    app.kubernetes.io/version: "1.0-RC30"
    app.kubernetes.io/managed-by: Helm
    app.kubernetes.io/component: rest
spec:
  revisionHistoryLimit: 3
  replicas: 1
  selector:
    matchLabels:

      app.kubernetes.io/name: geoservercloud
      app.kubernetes.io/instance: testwithveryveryverylongreleasename
      app.kubernetes.io/component: rest
  template:
    metadata:
      annotations:
        checksum/config: 090322f8c3cc601feeb74b7c2282e07fedc136db6688b8c52011fcba26e8e7f7
        specificValues/sha256: 3d845352867e525da0a8916c256f78fd5223b6fcebd9b7bfdab0644c9688f602
        globalValues/sha256: 130a2567c866307fcd6950b0976112984d2fac6b38c6e55b0a07b3ae8a866247
      labels:

        app.kubernetes.io/name: geoservercloud
        app.kubernetes.io/instance: testwithveryveryverylongreleasename
        app.kubernetes.io/component: rest
    spec:
      volumes:
        # we define an emptyDir that can be used by optional initContainers if needed
        - name: localshare
          emptyDir: {}
        - name: configs
          configMap:
            name: testwithveryveryverylongreleasename-geoser-config-configs
        - name: nfs-pv-storage-rasters
          persistentVolumeClaim:
           claimName: nfs-rasters-pv-claim

      serviceAccountName: testwithveryveryverylongreleasename-geoser
      securityContext:
        runAsUser: 630
      initContainers:
        - command:
          - /bin/bash
          - -c
          - touch /mnt/localshare/test.txt;
          image: busybox
          name: extract-config
          volumeMounts:
          - mountPath: /mnt/localshare/
            name: localshare
      containers:
        - name: rest
          securityContext:
            {}
          image: "sanitize.me/geoservercloud/geoserver-cloud-rest:1.0-RC30"
          imagePullPolicy: IfNotPresent
          env:
            - name: SPRING_PROFILES_ACTIVE
              value: "standalone,jdbcconfig"


            - name: GEOSERVER_BASE_PATH
              value:  /geoserver-cloud
            - name: GEOSERVER_DEBUG_INSTANCEID
              value: "true"
            - name: BACKEND_CATALOG
              value: "false"
            - name: BACKEND_DATA_DIRECTORY
              value: "false"
            - name: BACKEND_JDBCCONFIG
              value: "true"
            - name: JAVA_OPTS
              value: "-DALLOW_ENV_PARAMETRIZATION=true "
            - name: TOMCAT_ACCESSLOG_ENABLED
              value: "true"
            - name: TOMCAT_MBEANREGISTRY_ENABLED
              value: "true"
            - name: TOMCAT_THREADS_MIN_SPARE
              value: "5"
            - name: RABBITMQ_PASSWORD
              valueFrom:
                secretKeyRef:
                  name: testwithveryveryverylongreleasename-rabbitmq
                  key: rabbitmq-password
            - name: RABBITMQ_HOST
              value: testwithveryveryverylongreleasename-rabbitmq
            - name: RABBITMQ_PORT
              value: "5672"
            - name: RABBITMQ_USER
              value: geoserver
            - name: GWC_ENABLED
              value: "true"
          ports:
            - name: http
              containerPort: 8080
              protocol: TCP
            - name: health
              containerPort: 8081
              protocol: TCP
          volumeMounts:
            - name: localshare
              mountPath: /mnt/localshare
            - name: configs
              mountPath: /etc/gscloud
            - mountPath: "/var/geoserver/nfsrasters"
              name: nfs-pv-storage-rasters
          startupProbe:
            httpGet:
              path: /actuator/health/liveness
              port: health
            failureThreshold: 30
            periodSeconds: 10
          livenessProbe:
            httpGet:
              path: /actuator/health/liveness
              port: health
            periodSeconds: 10
            failureThreshold: 10
            initialDelaySeconds: 30
          readinessProbe:
            httpGet:
              path: /actuator/health/readiness
              port: health
            periodSeconds: 5

          resources:
            limits:
              cpu: 2
              memory: 2Gi
            requests:
              cpu: 0.1
              memory: 512Mi
---
# Source: ogscloud/charts/geoservercloud/templates/generic/service_and_deployment.yaml
# deployment wcs
apiVersion: apps/v1
kind: Deployment
metadata:
  name: testwithveryveryverylongreleasename-geoser-wcs
  labels:
    helm.sh/chart: geoservercloud-0.0.49
    deployed_by: helm
    app.kubernetes.io/app_environment: "master"
    app.kubernetes.io/base_environment: "dev"
    app.kubernetes.io/name: geoservercloud
    app.kubernetes.io/instance: testwithveryveryverylongreleasename
    app.kubernetes.io/version: "1.0-RC30"
    app.kubernetes.io/managed-by: Helm
    app.kubernetes.io/component: wcs
spec:
  revisionHistoryLimit: 3
  replicas: 1
  selector:
    matchLabels:

      app.kubernetes.io/name: geoservercloud
      app.kubernetes.io/instance: testwithveryveryverylongreleasename
      app.kubernetes.io/component: wcs
  template:
    metadata:
      annotations:
        checksum/config: 090322f8c3cc601feeb74b7c2282e07fedc136db6688b8c52011fcba26e8e7f7
        specificValues/sha256: e6263b0022444bd86d73b366c0875b0fdd0fdacaa7e2813046884bbb82197afd
        globalValues/sha256: 130a2567c866307fcd6950b0976112984d2fac6b38c6e55b0a07b3ae8a866247
      labels:

        app.kubernetes.io/name: geoservercloud
        app.kubernetes.io/instance: testwithveryveryverylongreleasename
        app.kubernetes.io/component: wcs
    spec:
      volumes:
        # we define an emptyDir that can be used by optional initContainers if needed
        - name: localshare
          emptyDir: {}
        - name: configs
          configMap:
            name: testwithveryveryverylongreleasename-geoser-config-configs
        - name: nfs-pv-storage-rasters
          persistentVolumeClaim:
           claimName: nfs-rasters-pv-claim

      serviceAccountName: testwithveryveryverylongreleasename-geoser
      securityContext:
        runAsUser: 630
      initContainers:
        - command:
          - /bin/bash
          - -c
          - touch /mnt/localshare/test.txt;
          image: busybox
          name: extract-config
          volumeMounts:
          - mountPath: /mnt/localshare/
            name: localshare
      containers:
        - name: wcs
          securityContext:
            {}
          image: "sanitize.me/geoservercloud/geoserver-cloud-wcs:1.0-RC30"
          imagePullPolicy: IfNotPresent
          env:
            - name: SPRING_PROFILES_ACTIVE
              value: "standalone,jdbcconfig"


            - name: GEOSERVER_BASE_PATH
              value:  /geoserver-cloud
            - name: GEOSERVER_DEBUG_INSTANCEID
              value: "true"
            - name: BACKEND_CATALOG
              value: "false"
            - name: BACKEND_DATA_DIRECTORY
              value: "false"
            - name: BACKEND_JDBCCONFIG
              value: "true"
            - name: JAVA_OPTS
              value: "-DALLOW_ENV_PARAMETRIZATION=true "
            - name: TOMCAT_ACCESSLOG_ENABLED
              value: "true"
            - name: TOMCAT_MBEANREGISTRY_ENABLED
              value: "true"
            - name: TOMCAT_THREADS_MIN_SPARE
              value: "5"
            - name: RABBITMQ_PASSWORD
              valueFrom:
                secretKeyRef:
                  name: testwithveryveryverylongreleasename-rabbitmq
                  key: rabbitmq-password
            - name: RABBITMQ_HOST
              value: testwithveryveryverylongreleasename-rabbitmq
            - name: RABBITMQ_PORT
              value: "5672"
            - name: RABBITMQ_USER
              value: geoserver
            - name: GWC_ENABLED
              value: "true"
          ports:
            - name: http
              containerPort: 8080
              protocol: TCP
            - name: health
              containerPort: 8081
              protocol: TCP
          volumeMounts:
            - name: localshare
              mountPath: /mnt/localshare
            - name: configs
              mountPath: /etc/gscloud
            - mountPath: "/var/geoserver/nfsrasters"
              name: nfs-pv-storage-rasters
          startupProbe:
            httpGet:
              path: /actuator/health/liveness
              port: health
            failureThreshold: 30
            periodSeconds: 10
          livenessProbe:
            httpGet:
              path: /actuator/health/liveness
              port: health
            periodSeconds: 10
            failureThreshold: 10
            initialDelaySeconds: 30
          readinessProbe:
            httpGet:
              path: /actuator/health/readiness
              port: health
            periodSeconds: 5

          resources:
            limits:
              cpu: 4
              memory: 4Gi
            requests:
              cpu: 0.1
              memory: 512Mi
---
# Source: ogscloud/charts/geoservercloud/templates/generic/service_and_deployment.yaml
# deployment webui
apiVersion: apps/v1
kind: Deployment
metadata:
  name: testwithveryveryverylongreleasename-geoser-webui
  labels:
    helm.sh/chart: geoservercloud-0.0.49
    deployed_by: helm
    app.kubernetes.io/app_environment: "master"
    app.kubernetes.io/base_environment: "dev"
    app.kubernetes.io/name: geoservercloud
    app.kubernetes.io/instance: testwithveryveryverylongreleasename
    app.kubernetes.io/version: "1.0-RC30"
    app.kubernetes.io/managed-by: Helm
    app.kubernetes.io/component: webui
  annotations:
    foo: bar
spec:
  revisionHistoryLimit: 3
  replicas: 1
  selector:
    matchLabels:

      app.kubernetes.io/name: geoservercloud
      app.kubernetes.io/instance: testwithveryveryverylongreleasename
      app.kubernetes.io/component: webui
  template:
    metadata:
      annotations:
        checksum/config: 090322f8c3cc601feeb74b7c2282e07fedc136db6688b8c52011fcba26e8e7f7
        specificValues/sha256: 1a9046ea8349ea9547ed76a3d9e9bce4020a1ef26737b72b7a273de4cc87a30c
        globalValues/sha256: 130a2567c866307fcd6950b0976112984d2fac6b38c6e55b0a07b3ae8a866247
      labels:

        app.kubernetes.io/name: geoservercloud
        app.kubernetes.io/instance: testwithveryveryverylongreleasename
        app.kubernetes.io/component: webui
    spec:
      volumes:
        # we define an emptyDir that can be used by optional initContainers if needed
        - name: localshare
          emptyDir: {}
        - name: configs
          configMap:
            name: testwithveryveryverylongreleasename-geoser-config-configs
        - name: nfs-pv-storage-rasters
          persistentVolumeClaim:
           claimName: nfs-rasters-pv-claim

      serviceAccountName: testwithveryveryverylongreleasename-geoser
      securityContext:
        runAsUser: 630
      initContainers:
        - command:
          - /bin/bash
          - -c
          - touch /mnt/localshare/test.txt;
          image: busybox
          name: extract-config
          volumeMounts:
          - mountPath: /mnt/localshare/
            name: localshare
      containers:
        - name: webui
          securityContext:
            {}
          image: "sanitize.me/geoservercloud/geoserver-cloud-webui:1.0-RC30"
          imagePullPolicy: IfNotPresent
          env:
            - name: SPRING_PROFILES_ACTIVE
              value: "standalone,jdbcconfig"


            - name: GEOSERVER_BASE_PATH
              value:  /geoserver-cloud
            - name: GEOSERVER_DEBUG_INSTANCEID
              value: "true"
            - name: BACKEND_CATALOG
              value: "false"
            - name: BACKEND_DATA_DIRECTORY
              value: "false"
            - name: BACKEND_JDBCCONFIG
              value: "true"
            - name: JAVA_OPTS
              value: "-DALLOW_ENV_PARAMETRIZATION=true "
            - name: TOMCAT_ACCESSLOG_ENABLED
              value: "true"
            - name: TOMCAT_MBEANREGISTRY_ENABLED
              value: "true"
            - name: TOMCAT_THREADS_MIN_SPARE
              value: "5"
            - name: RABBITMQ_PASSWORD
              valueFrom:
                secretKeyRef:
                  name: testwithveryveryverylongreleasename-rabbitmq
                  key: rabbitmq-password
            - name: RABBITMQ_HOST
              value: testwithveryveryverylongreleasename-rabbitmq
            - name: RABBITMQ_PORT
              value: "5672"
            - name: RABBITMQ_USER
              value: geoserver
            - name: GWC_ENABLED
              value: "true"
          ports:
            - name: http
              containerPort: 8080
              protocol: TCP
            - name: health
              containerPort: 8081
              protocol: TCP
          volumeMounts:
            - name: localshare
              mountPath: /mnt/localshare
            - name: configs
              mountPath: /etc/gscloud
            - mountPath: "/var/geoserver/nfsrasters"
              name: nfs-pv-storage-rasters
          startupProbe:
            httpGet:
              path: /actuator/health/liveness
              port: health
            failureThreshold: 30
            periodSeconds: 10
          livenessProbe:
            httpGet:
              path: /actuator/health/liveness
              port: health
            periodSeconds: 10
            failureThreshold: 10
            initialDelaySeconds: 30
          readinessProbe:
            httpGet:
              path: /actuator/health/readiness
              port: health
            periodSeconds: 5

          resources:
            limits:
              cpu: 2
              memory: 1024Mi
            requests:
              cpu: 0.1
              memory: 128Mi
---
# Source: ogscloud/charts/geoservercloud/templates/generic/service_and_deployment.yaml
# deployment wfs
apiVersion: apps/v1
kind: Deployment
metadata:
  name: testwithveryveryverylongreleasename-geoser-wfs
  labels:
    helm.sh/chart: geoservercloud-0.0.49
    deployed_by: helm
    app.kubernetes.io/app_environment: "master"
    app.kubernetes.io/base_environment: "dev"
    app.kubernetes.io/name: geoservercloud
    app.kubernetes.io/instance: testwithveryveryverylongreleasename
    app.kubernetes.io/version: "1.0-RC30"
    app.kubernetes.io/managed-by: Helm
    app.kubernetes.io/component: wfs
spec:
  revisionHistoryLimit: 3
  replicas: 1
  selector:
    matchLabels:

      app.kubernetes.io/name: geoservercloud
      app.kubernetes.io/instance: testwithveryveryverylongreleasename
      app.kubernetes.io/component: wfs
  template:
    metadata:
      annotations:
        checksum/config: 090322f8c3cc601feeb74b7c2282e07fedc136db6688b8c52011fcba26e8e7f7
        specificValues/sha256: a2909c1514e265546f27bcef30d65dd1e0a800fed6c4b2346c35dca12101c0ac
        globalValues/sha256: 130a2567c866307fcd6950b0976112984d2fac6b38c6e55b0a07b3ae8a866247
      labels:

        app.kubernetes.io/name: geoservercloud
        app.kubernetes.io/instance: testwithveryveryverylongreleasename
        app.kubernetes.io/component: wfs
    spec:
      volumes:
        # we define an emptyDir that can be used by optional initContainers if needed
        - name: localshare
          emptyDir: {}
        - name: configs
          configMap:
            name: testwithveryveryverylongreleasename-geoser-config-configs
        - name: nfs-pv-storage-rasters
          persistentVolumeClaim:
           claimName: nfs-rasters-pv-claim

      serviceAccountName: testwithveryveryverylongreleasename-geoser
      securityContext:
        runAsUser: 630
      initContainers:
        - command:
          - /bin/bash
          - -c
          - touch /mnt/localshare/test.txt;
          image: busybox
          name: extract-config
          volumeMounts:
          - mountPath: /mnt/localshare/
            name: localshare
      containers:
        - name: wfs
          securityContext:
            {}
          image: "sanitize.me/geoservercloud/geoserver-cloud-wfs:1.0-RC30"
          imagePullPolicy: IfNotPresent
          env:
            - name: SPRING_PROFILES_ACTIVE
              value: "standalone,jdbcconfig"


            - name: GEOSERVER_BASE_PATH
              value:  /geoserver-cloud
            - name: GEOSERVER_DEBUG_INSTANCEID
              value: "true"
            - name: BACKEND_CATALOG
              value: "false"
            - name: BACKEND_DATA_DIRECTORY
              value: "false"
            - name: BACKEND_JDBCCONFIG
              value: "true"
            - name: JAVA_OPTS
              value: "-DALLOW_ENV_PARAMETRIZATION=true "
            - name: TOMCAT_ACCESSLOG_ENABLED
              value: "true"
            - name: TOMCAT_MBEANREGISTRY_ENABLED
              value: "true"
            - name: TOMCAT_THREADS_MIN_SPARE
              value: "5"
            - name: RABBITMQ_PASSWORD
              valueFrom:
                secretKeyRef:
                  name: testwithveryveryverylongreleasename-rabbitmq
                  key: rabbitmq-password
            - name: RABBITMQ_HOST
              value: testwithveryveryverylongreleasename-rabbitmq
            - name: RABBITMQ_PORT
              value: "5672"
            - name: RABBITMQ_USER
              value: geoserver
            - name: GWC_ENABLED
              value: "true"
          ports:
            - name: http
              containerPort: 8080
              protocol: TCP
            - name: health
              containerPort: 8081
              protocol: TCP
          volumeMounts:
            - name: localshare
              mountPath: /mnt/localshare
            - name: configs
              mountPath: /etc/gscloud
            - mountPath: "/var/geoserver/nfsrasters"
              name: nfs-pv-storage-rasters
          startupProbe:
            httpGet:
              path: /actuator/health/liveness
              port: health
            failureThreshold: 30
            periodSeconds: 10
          livenessProbe:
            httpGet:
              path: /actuator/health/liveness
              port: health
            periodSeconds: 10
            failureThreshold: 10
            initialDelaySeconds: 30
          readinessProbe:
            httpGet:
              path: /actuator/health/readiness
              port: health
            periodSeconds: 5

          resources:
            limits:
              cpu: 4
              memory: 4Gi
            requests:
              cpu: 0.1
              memory: 512Mi
---
# Source: ogscloud/charts/geoservercloud/templates/generic/service_and_deployment.yaml
# deployment wms
apiVersion: apps/v1
kind: Deployment
metadata:
  name: testwithveryveryverylongreleasename-geoser-wms
  labels:
    helm.sh/chart: geoservercloud-0.0.49
    deployed_by: helm
    app.kubernetes.io/app_environment: "master"
    app.kubernetes.io/base_environment: "dev"
    app.kubernetes.io/name: geoservercloud
    app.kubernetes.io/instance: testwithveryveryverylongreleasename
    app.kubernetes.io/version: "1.0-RC30"
    app.kubernetes.io/managed-by: Helm
    app.kubernetes.io/component: wms
spec:
  revisionHistoryLimit: 3
  replicas: 1
  selector:
    matchLabels:

      app.kubernetes.io/name: geoservercloud
      app.kubernetes.io/instance: testwithveryveryverylongreleasename
      app.kubernetes.io/component: wms
  template:
    metadata:
      annotations:
        checksum/config: 090322f8c3cc601feeb74b7c2282e07fedc136db6688b8c52011fcba26e8e7f7
        specificValues/sha256: 61977953f997d969fabbdcbabdce0cf8315ea3e02b1c66c31ec2c1a76e753582
        globalValues/sha256: 130a2567c866307fcd6950b0976112984d2fac6b38c6e55b0a07b3ae8a866247
      labels:

        app.kubernetes.io/name: geoservercloud
        app.kubernetes.io/instance: testwithveryveryverylongreleasename
        app.kubernetes.io/component: wms
    spec:
      volumes:
        # we define an emptyDir that can be used by optional initContainers if needed
        - name: localshare
          emptyDir: {}
        - name: configs
          configMap:
            name: testwithveryveryverylongreleasename-geoser-config-configs
        - name: nfs-pv-storage-rasters
          persistentVolumeClaim:
           claimName: nfs-rasters-pv-claim

      serviceAccountName: testwithveryveryverylongreleasename-geoser
      securityContext:
        runAsUser: 630
      initContainers:
        - command:
          - /bin/bash
          - -c
          - touch /mnt/localshare/test.txt;
          image: busybox
          name: extract-config
          volumeMounts:
          - mountPath: /mnt/localshare/
            name: localshare
      containers:
        - name: wms
          securityContext:
            {}
          image: "sanitize.me/geoservercloud/geoserver-cloud-wms:1.0-RC30"
          imagePullPolicy: IfNotPresent
          env:
            - name: SPRING_PROFILES_ACTIVE
              value: "standalone,jdbcconfig"


            - name: GEOSERVER_BASE_PATH
              value:  /geoserver-cloud
            - name: GEOSERVER_DEBUG_INSTANCEID
              value: "true"
            - name: BACKEND_CATALOG
              value: "false"
            - name: BACKEND_DATA_DIRECTORY
              value: "false"
            - name: BACKEND_JDBCCONFIG
              value: "true"
            - name: JAVA_OPTS
              value: "-DALLOW_ENV_PARAMETRIZATION=true "
            - name: TOMCAT_ACCESSLOG_ENABLED
              value: "true"
            - name: TOMCAT_MBEANREGISTRY_ENABLED
              value: "true"
            - name: TOMCAT_THREADS_MIN_SPARE
              value: "5"
            - name: RABBITMQ_PASSWORD
              valueFrom:
                secretKeyRef:
                  name: testwithveryveryverylongreleasename-rabbitmq
                  key: rabbitmq-password
            - name: RABBITMQ_HOST
              value: testwithveryveryverylongreleasename-rabbitmq
            - name: RABBITMQ_PORT
              value: "5672"
            - name: RABBITMQ_USER
              value: geoserver
            - name: GWC_ENABLED
              value: "true"
          ports:
            - name: http
              containerPort: 8080
              protocol: TCP
            - name: health
              containerPort: 8081
              protocol: TCP
          volumeMounts:
            - name: localshare
              mountPath: /mnt/localshare
            - name: configs
              mountPath: /etc/gscloud
            - mountPath: "/var/geoserver/nfsrasters"
              name: nfs-pv-storage-rasters
          startupProbe:
            httpGet:
              path: /actuator/health/liveness
              port: health
            failureThreshold: 30
            periodSeconds: 10
          livenessProbe:
            httpGet:
              path: /actuator/health/liveness
              port: health
            periodSeconds: 10
            failureThreshold: 10
            initialDelaySeconds: 30
          readinessProbe:
            httpGet:
              path: /actuator/health/readiness
              port: health
            periodSeconds: 5

          resources:
            limits:
              cpu: 4
              memory: 4Gi
            requests:
              cpu: 0.1
              memory: 512Mi
---
# Source: ogscloud/charts/geoservercloud/charts/rabbitmq/templates/statefulset.yaml
apiVersion: apps/v1
kind: StatefulSet
metadata:
  name: testwithveryveryverylongreleasename-rabbitmq
  namespace: "default"
  labels:
    app.kubernetes.io/name: rabbitmq
    helm.sh/chart: rabbitmq-11.3.0
    app.kubernetes.io/instance: testwithveryveryverylongreleasename
    app.kubernetes.io/managed-by: Helm
spec:
  serviceName: testwithveryveryverylongreleasename-rabbitmq-headless
  podManagementPolicy: OrderedReady
  replicas: 1
  updateStrategy:
    type: RollingUpdate
  selector:
    matchLabels:
      app.kubernetes.io/name: rabbitmq
      app.kubernetes.io/instance: testwithveryveryverylongreleasename
  template:
    metadata:
      labels:
        app.kubernetes.io/name: rabbitmq
        helm.sh/chart: rabbitmq-11.3.0
        app.kubernetes.io/instance: testwithveryveryverylongreleasename
        app.kubernetes.io/managed-by: Helm
      annotations:
        checksum/config: 93ef00cf9e3c0c7e51dbc61a9fc29da3f14258a262bbb75ea05064b652f54334
        checksum/secret: 38026d382e76771b650df14b9c775fd208a74c7d01289b6c64effefd109ecd0d
    spec:

      serviceAccountName: testwithveryveryverylongreleasename-rabbitmq
      affinity:
        podAffinity:

        podAntiAffinity:
          preferredDuringSchedulingIgnoredDuringExecution:
            - podAffinityTerm:
                labelSelector:
                  matchLabels:
                    app.kubernetes.io/name: rabbitmq
                    app.kubernetes.io/instance: testwithveryveryverylongreleasename
                topologyKey: kubernetes.io/hostname
              weight: 1
        nodeAffinity:

      securityContext:
        fsGroup: 1001
      terminationGracePeriodSeconds: 120
      initContainers:
      containers:
        - name: rabbitmq
          image: docker.io/bitnami/rabbitmq:3.9.13-debian-10-r14
          imagePullPolicy: "IfNotPresent"
          securityContext:
            runAsNonRoot: true
            runAsUser: 1001
          lifecycle:
            preStop:
              exec:
                command:
                  - /bin/bash
                  - -ec
                  - |
                    if [[ -f /opt/bitnami/scripts/rabbitmq/nodeshutdown.sh ]]; then
                        /opt/bitnami/scripts/rabbitmq/nodeshutdown.sh -t "120" -d "false"
                    else
                        rabbitmqctl stop_app
                    fi
          env:
            - name: BITNAMI_DEBUG
              value: "false"
            - name: MY_POD_IP
              valueFrom:
                fieldRef:
                  fieldPath: status.podIP
            - name: MY_POD_NAME
              valueFrom:
                fieldRef:
                  fieldPath: metadata.name
            - name: MY_POD_NAMESPACE
              valueFrom:
                fieldRef:
                  fieldPath: metadata.namespace
            - name: K8S_SERVICE_NAME
              value: testwithveryveryverylongreleasename-rabbitmq-headless
            - name: K8S_ADDRESS_TYPE
              value: hostname
            - name: RABBITMQ_FORCE_BOOT
              value: "no"
            - name: RABBITMQ_NODE_NAME
              value: "rabbit@$(MY_POD_NAME).$(K8S_SERVICE_NAME).$(MY_POD_NAMESPACE).svc.cluster.local"
            - name: K8S_HOSTNAME_SUFFIX
              value: ".$(K8S_SERVICE_NAME).$(MY_POD_NAMESPACE).svc.cluster.local"
            - name: RABBITMQ_MNESIA_DIR
              value: "/bitnami/rabbitmq/mnesia/$(RABBITMQ_NODE_NAME)"
            - name: RABBITMQ_LDAP_ENABLE
              value: "no"
            - name: RABBITMQ_LOGS
              value: "-"
            - name: RABBITMQ_ULIMIT_NOFILES
              value: "65536"
            - name: RABBITMQ_USE_LONGNAME
              value: "true"
            - name: RABBITMQ_ERL_COOKIE
              valueFrom:
                secretKeyRef:
                  name: testwithveryveryverylongreleasename-rabbitmq
                  key: rabbitmq-erlang-cookie
            - name: RABBITMQ_LOAD_DEFINITIONS
              value: "no"
            - name: RABBITMQ_DEFINITIONS_FILE
              value: "/app/load_definition.json"
            - name: RABBITMQ_SECURE_PASSWORD
              value: "yes"
            - name: RABBITMQ_USERNAME
              value: "geoserver"
            - name: RABBITMQ_PASSWORD
              valueFrom:
                secretKeyRef:
                  name: testwithveryveryverylongreleasename-rabbitmq
                  key: rabbitmq-password
            - name: RABBITMQ_PLUGINS
              value: "rabbitmq_management, rabbitmq_peer_discovery_k8s, rabbitmq_auth_backend_ldap"
          envFrom:
          ports:
            - name: amqp
              containerPort: 5672
            - name: dist
              containerPort: 25672
            - name: stats
              containerPort: 15672
            - name: epmd
              containerPort: 4369
          livenessProbe:
            failureThreshold: 6
            initialDelaySeconds: 120
            periodSeconds: 30
            successThreshold: 1
            timeoutSeconds: 20
            exec:
              command:
                - /bin/bash
                - -ec
                - rabbitmq-diagnostics -q ping
          readinessProbe:
            failureThreshold: 3
            initialDelaySeconds: 10
            periodSeconds: 30
            successThreshold: 1
            timeoutSeconds: 20
            exec:
              command:
                - /bin/bash
                - -ec
                - rabbitmq-diagnostics -q check_running && rabbitmq-diagnostics -q check_local_alarms
          resources:
            limits:
              cpu: 2
              memory: 2Gi
            requests:
              cpu: 0.1
              memory: 512Mi
          volumeMounts:
            - name: configuration
              mountPath: /bitnami/rabbitmq/conf
            - name: data
              mountPath: /bitnami/rabbitmq/mnesia
      volumes:
        - name: configuration
          projected:
            sources:
              - secret:
                  name: testwithveryveryverylongreleasename-rabbitmq-config
        - name: data
          emptyDir: {}
